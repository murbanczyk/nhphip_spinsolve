#########################################################
# 
# IR_bubble_1D_SEPP_WET
#  
# A pulse sequence suitable for performing a
# pulse and collect experiment on hydrogen nuclei
# in the Spinsolve Spectrometer.
#
#
# The acquisition delay is optimised to reduce 1st order
# phase errors when the data is shifted forward in time 
# (effectively putting the missed data at time zero where 
# it just introduces a baseline offset.)
#
# pulse - delay - acq
#
# Copyright (c) Magritek Ltd 2024
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(IR_bubble_1D_SEPP_WET, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"IR_bubble_1D_SEPP_WET")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("IR_bubble_1D_SEPP_WET")
   else
      gExpt->addExperiment(ppGroup,"IR_bubble_1D_SEPP_WET",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["tSoft"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nDataPnts  = nrPnts",
          "a90Amp     = 90Amplitude1H",
          "d90Dur     = pulseLength1H",
          "d45        = pulseLength1H*0.5",
          "centerFreq1HPPM = centerFreqPPM",
          "offFreq1H            = (centerFreq1HPPM-wvPPMOffset1H)*b1Freq1H",
          "offFreq13C           = (centerFreq13CPPM-wvPPMOffset13C)*b1Freq13C",
          "O1                   = offFreq1H",
          "f1H                  = double(b1Freq1H)+double(offFreq1H/1e6d)",
          "f13C                 = double(b1Freq13C)+double(offFreq13C/1e6d)",
          "nPnts                = nrPnts",
          "d90H                 = pulseLengthH90",
          "a90H                 = amplitudeH90",
          "d90C                 = pulseLengthC180/2",
          "d180C                = pulseLengthC180",
          "d270C                = 3*pulseLengthC180/2",
          "d360C                = 2*pulseLengthC180",
          "aDec                 = decoupleAmpAcq",
          "nAcquire             = decoupleAcq==\"no\"",
          "nDecouple            = decoupleAcq==\"yes\"",
          "waltzDuration        = WALTZ16:duration(pulseLengthC180/2,pgo)",
          "nLoops               = trunc(1000*acqTime/waltzDuration)+1",
          "totPnts              = nrPnts",
          "totTime              = acqTime",
          "dAcqDelay            =(0.255*dwellTime-0.63)-(0.57117 + 0.000145*dwellTime)*d90H",
          "nxShim               = xshim",
          "nyShim               = yshim",
          "nzShim               = zshim",
          "dSpoilWet            = spoilDurWet",
          "dStabWet             = gradStabWet",
          "nxSpoil1w            = xshim-sign(xshim)*spoilAmpWet/1",
          "nxSpoil2w            = xshim-sign(xshim)*spoilAmpWet/2",
          "nxSpoil3w            = xshim-sign(xshim)*spoilAmpWet/4",
          "nxSpoil4w            = xshim-sign(xshim)*spoilAmpWet/8",
          "nySpoil1w            = yshim-sign(yshim)*spoilAmpWet/8",
          "nySpoil2w            = yshim-sign(yshim)*spoilAmpWet/4",
          "nySpoil3w            = yshim-sign(yshim)*spoilAmpWet/2",
          "nySpoil4w            = yshim-sign(yshim)*spoilAmpWet/1",
          "nzSpoil1w            = zshim-sign(zshim)*spoilAmpWet/1",
          "nzSpoil2w            = zshim-sign(zshim)*spoilAmpWet/2",
          "nzSpoil3w            = zshim-sign(zshim)*spoilAmpWet/4",
          "nzSpoil4w            = zshim-sign(zshim)*spoilAmpWet/8",
          "nzSup                = zshim-sign(zshim)*supAmp",
          "aSup1                = aSoft90 - 1.0",
          "aSup2                = aSoft90 + 1.0",
          "aSup3                = aSoft90 - 2.0",
          "aSup4                = aSoft90 + 5.0",
          "(tAmpPhase1,nTabSz,dStep) = getwetpar1(1000*pulseLengthPs,Osup1,aSup1,useSup1,Osup2,useSup2,Osup3,useSup3,b1Freq1H,decoupleAmpPre,decouplePre,pulseLengthC180/2,centerFreq1HPPM)",
          "(tAmpPhase2,nTabSz,dStep) = getwetpar1(1000*pulseLengthPs,Osup1,aSup2,useSup1,Osup2,useSup2,Osup3,useSup3,b1Freq1H,decoupleAmpPre,decouplePre,pulseLengthC180/2,centerFreq1HPPM)",
          "(tAmpPhase3,nTabSz,dStep) = getwetpar1(1000*pulseLengthPs,Osup1,aSup3,useSup1,Osup2,useSup2,Osup3,useSup3,b1Freq1H,decoupleAmpPre,decouplePre,pulseLengthC180/2,centerFreq1HPPM)",
          "(tAmpPhase4,nTabSz,dStep) = getwetpar1(1000*pulseLengthPs,Osup1,aSup4,useSup1,Osup2,useSup2,Osup3,useSup3,b1Freq1H,decoupleAmpPre,decouplePre,pulseLengthC180/2,centerFreq1HPPM)",
          "(tSoft,dummy,n301,d301) = getwetpar2(supAmplitude,supDuration,supRange,supOffset)",
          "nGradShim            = oshim",
          "gradRamp             = 0.1",
          "nRampSteps           = 10",
          "dRampStep            = 1000*gradRamp/nRampSteps",
          "dp16       = p16*1000-dRampStep*2*nRampSteps",
          "dp19       = p19*1000-dRampStep*2*nRampSteps",
          "(digGradAmp3,gradAmp3) = IR_bubble_1D_SEPP_WET_pp:getGradients(gradAmpPC3,oshim)",
          "(digGradAmp4,gradAmp4) = IR_bubble_1D_SEPP_WET_pp:getGradients(gradAmpPC4,oshim)",
          "(digGradAmp5,gradAm5p) = IR_bubble_1D_SEPP_WET_pp:getGradients(gradAmpPC5,oshim)",
          "tAmpPhase = IR_bubble_1D_SEPP_WET_pp:getAmpPhaseTable( tableFileNameAmp, tableFileNamePh, ShapedAmplitude)",
          "nGradShim            = oshim",
          "nGrad3                = digGradAmp3+oshim",
          "nGrad4                = digGradAmp4+oshim",
          "nGrad5                = digGradAmp5+oshim",
          "d16       =del16*1000",
          "d4       = 1000000/(cnst1*4)-dp16-d16",
          "d19       =del19*1000",
          "ntsize =shapepoints",
          "dstept = shaplength*1000/ntsize",
          "dAcqDelay  = ucsUtilities:getacqDelay(d90Dur,shiftPoints,dwellTime)",
          "offFreq1H  = (centerFreqPPM-wvPPMOffset1H)*b1Freq1H",
          "freqCh1    = double(b1Freq1H)+double(offFreq1H/1e6d)",
          "freqRx     = freqCh1",
          "totPnts    = nrPnts",
          "totTime    = acqTime"]
   var = ["tSoft"]
   pp_list = ["aDec","f13C","f1H","tAmpPhase1","p4","nTabSz","dStep","nxSpoil1w","nySpoil1w","nzSpoil1w","dSpoilWet","nxShim","nyShim","nzShim","dStabWet","tAmpPhase2","nxSpoil2w","nySpoil2w","nzSpoil2w","tAmpPhase3","nxSpoil3w","nySpoil3w","nzSpoil3w","tAmpPhase4","nxSpoil4w","nySpoil4w","nzSpoil4w","nzSup","tSoft","n301","d301","a90Amp","p1","d45","d4","nGradShim","nGrad3","nRampSteps","dRampStep","dp16","d16","tAmpPhase","p2","ntsize","dstept","p3","d90Dur","nGrad4","nGrad5","dp19","d19","p5","dAcqDelay","nDataPnts"]
   pp_name = "IR_bubble_1D_SEPP_WET.p"
   phase_list = [0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,3,3,1,1,3,3,1,1,3,3,1,1,3,3;0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3;1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0;0,2,2,0,1,3,3,1,2,0,0,2,3,1,1,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#########################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# March 2021 CDE
#########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)
(tSoft1,tSoft2) = getwetpar2(supAmplitude,supDuration,supRange,supOffset)

# Allocate space for output data
   sumData = cmatrix(totPnts)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # us
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Intialise phase correction
   phCor = 0

# Hide the FID
#  gPlot->layoutPlots(["pt2"],"keep")
#  gPlot->showPlots(["pt2"])

# Get plot regions
   (prt,prf) = ucsPlot:getPlotReferences()
   prt->showimag("false")
   prf->showimag("false")

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, guipar)
exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 1")
# Accumulate scans
pause(11)
   for(scan = -dummyScans to nrScans-1)
   if(scan == 0)
         sumData = sumData*0
      endif

 if(gData->procType == "FX3")
         if((scan%2 == 0) | (scan < 0))
            gFX3->modifyTable(tSoft1, tSoft)
         else
            gFX3->modifyTable(tSoft2, tSoft)
         endif
endif


 ucsUtilities:suspendLock() # turn lock control loop off
pause(0.05)
    # Check timing, update the parameters, run the sequence and return the data
exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 2")
pause(2)
       ucsUtilities:resumeLock()  # turn lock control loop on
pause(0.5)
      (data,pAcq,status) = ucsRun:runSequence(guipar,ppList,pcList,pcIndex,scan)

    # See if the abort button has been pressed
      if(status == "abort")
         return(0)
      endif

    # Correct for p1 errors
      if(isvar("shiftPoints"))
   
       # Shift the data to minimise p1
         data = shift(data,round(shiftPoints)) 
   
       # Correct the distortions in start of FID due to digital filter 
         data = ucsUtilities:correctFilter1(data,dwellTime)
   
      endif

    # Accumlate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

   #  sound(real(sumData),round(2048*4),"scale")

    # Correct the first data point
      datacorr = ucsRun:correctFirstDataPoint(sumData,shiftPoints,fdPhaseCorr)

    # Process data
      (phasedTimeData,spectrum,ph0) = ucsRun:transformData(zerofill(datacorr.*flt,zf*totPnts,"end"),fAxis,guipar,"fid",1,1)

    # Plot the data 
      ucsPlot:graphTimeAndFreq(prt,prf,tAxis,datacorr,fAxisDisp,spectrum,scan,guipar,
                               "Time data (scan : $scan+1$)","Spectral data",
                               "","",
                               fAxisLabel,"Amplitude")

    # Check if complete button pressed
      if(status == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)
exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 3")

# Save the data
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(prf,:getPlotInfo("pt2"),guipar,"simpleReport")
   ucsFiles:saveMNovaData(prt,"",guipar,"simpleReport",phase0=ph0)

# Save the processing parameters
   :saveProcPar(guipar,ph0,fRange)

# Pack the data into a structure
   result = struct()
   result->tAxis = tAxis
   result->tData = sumData/scan
   result->fAxis = fAxisDisp
   result->fData = spectrum/scan
   result->par = struct(guipar)
   result->p0 = phCor/pi*180+ph0

# Return result
   return(result)

endproc("execpp") # Don't remove argument


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000 +11+2*totScans

endproc(duration)


procedure( getTableFileAmp )

   objNr = findobj(0,"name","tableFileNameAmp")
print(getcwd())

   tableFileName = getobj(0,objNr)->text
   fileName = getfilename("open", "Select Amplitude table", "Table files", "txt", tableFileName)
print(getcwd())

   fileName=getcwd() +"\\" + fileName
   print(fileName)

   getobj(0,objNr)->text(fileName)
  

import1dpar("ab", "ascii", "xyrc", "real")
Amplitude=import1d(fileName)

(xs,xx)=size(Amplitude)
print(xs)
 objNr2 = findobj(0,"name","shapepoints")

   getobj(0,objNr2)->text(xs)
 
endproc()


procedure( getTableFilePhase )

   objNr = findobj(0,"name","tableFileNamePh")
   tableFileName = getobj(0,objNr)->text
print(getcwd())
   fileName = getfilename("open", "Select Phase table", "Table files", "txt", tableFileName)
   fileName=getcwd() +"\\" + fileName

   print(fileName)
print(getcwd())

   getobj(0,objNr)->text(fileName)

endproc()
 



#################################
# Save the processing parameters
#################################

procedure(saveProcPar,guipar,p0,xrange)

   assignlist(guipar)
  
   if(saveData == "false")
      return
   endif

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
   endif

   procpar = ["apodizationFunction = \"$filterType$\"",
              "baseLineCorrectionMethod = \"None\"",
              "displayInPPM = \"$usePPMScale$\"",
              "ftOrigin = \"Start\"",
              "ftType = \"Complex\"",
              "p0Phase = $p0$",
              "p1Phase = 0",
              "p1Pivot = 0",
              "p1FixedPhase = 0",
              "phaseMethod = \"p0, p1 fixed phase\"",
              "ppmOffset = $centerFreqPPM$",
              "zeroFill = $zf$",
              "plotWidth = $xrange[1]-xrange[0]$",
              "plotStart = $xrange[0]$",
              "shiftPoints = 1"]

   if(isvar("exptNr"))
      cd("$dataDirectory$\\$expName$\\$exptNr$")
   else
      cd("$dataDirectory$\\$expName$")
   endif

   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif
   save("proc.par",procpar)

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()


