#########################################################
# 
# IR_bubble_2D_ZQCOSY_NUS_listFile
#
# A pulse sequence suitable for performing a
# gradient selected 2D IR_bubble_2D_ZQCOSY_NUS_listFile NMR experiment.
#
# Adaptiation of COSY ZQ sequence compatible with Indrek Reile bubling apparatus. Requires TTL emulation 
#using arduino and python script to communicate with arduino.  
# Shaped pulse has to be created using Topspin ShapeTool and
# converted to Prospa format by UFTOOLBOX (in MATLAB)
#
# Copyright (c) Mateusz Urbanczyk IChF PAN 2024
# Copyright (c) Magritek Ltd 2024
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(IR_bubble_2D_ZQCOSY_NUS_listFile, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"IR_bubble_2D_ZQCOSY_NUS_listFile")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("IR_bubble_2D_ZQCOSY_NUS_listFile")
   else
      gExpt->addExperiment(ppGroup,"IR_bubble_2D_ZQCOSY_NUS_listFile",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["wEvol"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

# Provide a pilot Proton scan for MNova
  # if(RunPilot("IR_bubble_2D_ZQCOSY_NUS_listFile","Proton",guipar) == 0)
   #   return(0)
   #endif

# Run the IR_bubble_2D_ZQCOSY_NUS_listFile  
   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["n1          = nrPnts",
          "nxShim      = xshim",
          "nyShim      = yshim",
          "nzShim      = zshim",
          "ny          = (yshim-1.0*spoilAmp)",
          "nx          = (xshim-1.0*spoilAmp)",
          "nz          = (zshim-1.0*spoilAmp)",
          "dX          = IR_bubble_2D_ZQCOSY_NUS_listFile_pp:GetPulseLength(cosyType, pulseLength1H)",
          "a90Amp         = 90Amplitude1H",
          "d90Dur         = pulseLength1H",
          "a90          = 90Amplitude1H",
          "d90        = pulseLength1H",
          "bandwidth2  = single(bandwidthf1PPM*b1Freq1H/1000)",
          "wEvol       = 5e2* NUSincs/bandwidth2",
          "dSpoil      = spoilDelay",
          "dStab       = gradStab",
          "d45        = pulseLength1H*0.5",
          "w1 = dd1*1000",
          "nGradShim            = oshim",
          "gradRamp             = 0.1",
          "nRampSteps           = 10",
          "dRampStep            = 1000*gradRamp/nRampSteps",
          "dp16       = p16*1000-dRampStep*2*nRampSteps",
          "dp19       = p19*1000-dRampStep*2*nRampSteps",
          "(digGradAmp2,gradAmp2) = IR_bubble_1D_SEPP_pp:getGradients(gradAmpPC2,oshim)",
          "(digGradAmp1,gradAmp1) = IR_bubble_1D_SEPP_pp:getGradients(gradAmpPC1,oshim)",
          "(digGradAmp3,gradAmp3) = IR_bubble_1D_SEPP_pp:getGradients(gradAmpPC3,oshim)",
          "(digGradAmp4,gradAmp4) = IR_bubble_1D_SEPP_pp:getGradients(gradAmpPC4,oshim)",
          "(digGradAmp5,gradAm5p) = IR_bubble_1D_SEPP_pp:getGradients(gradAmpPC5,oshim)",
          "tAmpPhase = IR_bubble_1D_SEPP_pp:getAmpPhaseTable( tableFileNameAmp, tableFileNamePh, ShapedAmplitude)",
          "nGradShim            = oshim",
          "nGrad1                = digGradAmp1+oshim",
          "nGrad2                = digGradAmp2+oshim",
          "nGrad3                = digGradAmp3+oshim",
          "nGrad4                = digGradAmp4+oshim",
          "nGrad5                = digGradAmp5+oshim",
          "d16       =del16*1000",
          "d666  = p16/2*1000",
          "d4u = 4",
          "d4       = 1000000/(cnst1*4)-dp16-d16-dRampStep*2*nRampSteps",
          "d19       =del19*1000",
          "ntsize =shapepoints",
          "dstept = shaplength*1000/ntsize",
          "offFreq1H   = (centerFreqPPM-wvPPMOffset1H)*b1Freq1H",
          "freqCh1 = b1Freq1H + offFreq1H/1e6d",
          "totPnts     = nrPnts",
          "totTime     = acqTime"]
   var = ["wEvol"]
   pp_list = ["w1","a90","p1","d90","wEvol","nGradShim","nGrad1","nRampSteps","dRampStep","dp16","d16","tAmpPhase","p2","ntsize","dstept","nGrad2","a90Amp","p3","d90Dur","d4","nGrad3","p4","nGrad4","p5","nGrad5","dp19","d19","n1"]
   pp_name = "IR_bubble_2D_ZQCOSY_NUS_listFile.p"
   phase_list = [0,0,0,0;1,1,1,1;0,0,2,2;0,2,0,2;0,0,0,0;0,2,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 2017-2021 CDE
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)


nrSteps=NUSdensity

import1dpar("ab", "ascii", "xyrc", "real")
NUSschedule=import1d(tableFileNUS)

#   (NUSschedule, nrSteps) = NUS:getNUSschedule(NUSincs, NUSdensity)


# Storage for output data
 

   sumData2D   = cmatrix(totPnts, NUSincs)
   sumData2D2   = cmatrix(totPnts, nrSteps)
   imageData2D = cmatrix(totPnts*zf, nrSteps*zf)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000            # ms
   fAxis = ([0:1:zf*totPnts-1]-zf*totPnts/2)/totTime/zf*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Make subplots. wvPP is the current-plot's parent
   (prt,prf,pd1,pd2) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# First order phase correction
   guipar = guipar + ["firstOrderCorr = 2*pi"]

# Work out frequency axes scales, labels and ranges
   (fAxisDisp,fAxisLabel,axisLabely,
    axisLabelx,axisY,axisX,yRange,xRange) = ucsPlot:generate2DFrequencyAxes(prf, pd2, fAxis, b1Freq1H, b1Freq1H, 
                                                                            wvPPMOffset1H, wvPPMOffset1H, 
                                                                            offFreq1H, offFreq1H, 
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            guipar)

# f1 bandwidth
   bw2Hz = bandwidth2*1000

exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 1")
 
pause(11)
# Loop over the evolution time
   for(evolutionStep = -dummyCycles to nrSteps-1)   # evolutionStep < 0 is dummy scan

   # FAD phase cycle to move zero frequency spike to edge
       pcListFAD = pcList
       if (evolutionStep >= 0)
          pcListFAD[~,0] = (pcList[~,0] + (NUSschedule[evolutionStep] % 2)*32768)
          pcListFAD[~,2] = (pcList[~,2] + (NUSschedule[evolutionStep] % 2)*32768)
      endif

    # Set the evolution time
      if(NUSschedule[evolutionStep] > 0)
         evolutionTime = 1e6/bw2Hz*(NUSschedule[evolutionStep])*0.5
            else
         evolutionTime = 2    
  endif
   

print("evol time before")
print(NUSschedule[evolutionStep])
print("gradient time:")
print(p16*1000)
      wEvol = evolutionTime# -d90-pgo

print("evolution time:")
print(wEvol)
#if (wEvol<0)
#wEvol=10
#endif

      ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],wEvol)
 
   # Initialise row data
      sumData = cmatrix(totPnts)

   # Accumulate scan
      for(scan = 0 to nrScans-1)

       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcListFAD,pcIndex)

       # Send all parameter values to DSP
         ucsRun:updatePPParameters(ppList,guipar)  

       # Wait for the repetition time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif

 ucsUtilities:suspendLock() # turn lock control loop off
pause(0.05)
    # Check timing, update the parameters, run the sequence and return the data
exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 2")
pause(2)
       ucsUtilities:resumeLock()  # turn lock control loop on
pause(0.5)


       # Run the pulse program and collect the data
          ucsUtilities:suspendLock() # turn lock control loop off
         (status,data) = ucsRun:getData(totPnts,guipar)
          ucsUtilities:resumeLock()  # turn lock control loop on

       # See if stop button/escape key pressed
         if(status != "ok")
            return(0)
         endif
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Transform the 1D data
         (phasedTimeData,spectrum) = ucsRun:transformData(zerofill(sumData.*flt, totPnts*zf, "end"),fAxis,guipar,"fid")

       # Plot the 1D data 
         if(evolutionStep < 0)
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - dummy cycle $-evolutionStep$, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         else
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - evolution time = $evolutionTime/1000,1.3f$ ms, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         endif

         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
    
      next(scan) # End of accumulation loop

    # Record the FID data and then FT it. Display results as images.
      if(evolutionStep >= 0)
      # Record the data
         sumData2D[~,NUSschedule[evolutionStep]] = sumData
         sumData2D2[~,evolutionStep] = sumData
 
      # FT the data
         imageData2D = :2dRF(sumData2D2,zf*totPnts,nrSteps*zf,"sinebellsquared","sinebellsquared","FTFid","FTFid","yes")
         imageData2D = reflect(imageData2D,"horiz")
         #imageData2D = reflect(imageData2D,"vert")

      # Plot the time domain data
         pd1->draw("false")
         pd2->draw("false")
         pd1->image(sumData2D,[tAxis[0],tAxis[-1]]/1e6,[1,nrSteps]/bw2Hz)
         pd1->xlabel("t2 - Acquisition time (s)")
         pd1->ylabel("t1 - Evolution time (s)")
         pd1->title("Raw data ($(100*(evolutionStep+1)/nrSteps),1.1f$%)")
      # Plot the IR_bubble_2D_ZQCOSY_NUS_listFile data
         mn = 30*sd(imageData2D[[0:63],~])
         mx =mn*2
         
         pd2->image(imageData2D,axisX,axisY)
         pd2->contour(10,2)
         pd2->datamapping("log")
         pd2->autorange("false")
         #pd2->imagerange(mn,mx)
         pd2->title("2D IR_bubble_2D_ZQCOSY_NUS_listFile spectrum")
         pd2->xlabel("f2 - 1H (ppm)")
         pd2->ylabel("f1 - 1H (ppm)")
         pd2->grid->xgrid("true")
         pd2->grid->ygrid("true")
         pd2->grid->finexgrid("true")
         pd2->grid->fineygrid("true")
         pd2->axes->xrange(xRange)
         pd2->axes->yrange(yRange)
         pd1->draw("true")
         pd2->draw("true")
      endif

    # Exit from experiment if finished
      if(check == "finish")
         exitfor()
      endif

   next(evolutionStep) # End of evolution time loop
exec("pythonw.exe", "C:\\Users\\Spinsolve\\sendcommandTTL.py 3")

# Save the data
   ucsFiles:saveImage(pd1,:getPlotInfo("im1"),guipar,"noReport")
   ucsFiles:saveImage(pd2,:getPlotInfo("im2"),guipar,"simpleReport")
#   ucsFiles:saveMNovaData(pd1,"data.2d",guipar,"simpleReport")
   ucsFiles:saveMNovaData(sumData2D2,"data",guipar,"simpleReport")
   ucsFiles:save2DData(guipar,sumData2D,"data_big")

# Save the processing parameters
   :saveProcPar(guipar,xRange,yRange)

# Pack the data for return
   result = struct()
   result->mTime     = sumData2D/scan
   result->mTimeAxes = [tAxis[0]/1e6,tAxis[-1]/1e6,1/bw2Hz,nrSteps/bw2Hz]
   result->mFreq     = imageData2D/scan
   result->mFreqAxes = [fAxis[0],fAxis[-1],-bw2Hz,bw2Hz]
   result->par       = struct(guipar)
   

         NUSflg = 1
      cd("$dataDirectory$\\$expName$")
      if(isfile("acqu.par"))
         apar = load("acqu.par")
         NUSlist = ["NUSschedule = $NUSschedule$",
                    "NUSdensity = $NUSdensity$",
                    "NUSflg = $NUSflg$",
                    "NUSincs = $NUSincs$"]
         acqpar = mergelists(apar,NUSlist)
         #pr acqpar  
         save("acqu.par",acqpar)
      endif
   

# Return the results
   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (NUSincs*NUSdensity*0.01+dummyCycles)*nrScans + useStartDelay  
   duration = totScans*repTime/1000+11+2*totScans

# Add pilot scan time
   if(useStartDelay)
      duration = duration + 10
   else
      duration = duration + 7
   endif
   if(useEndDelay)
      duration = duration + 10
   endif

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","cosyFID.pt2","im2","cosySpectrum.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

#################################
# Save the processing parameters
#################################

procedure(saveProcPar,guipar,xrange,yrange)

   assignlist(guipar)

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
      yrange = yrange*single(b1Freq1H)
   endif

   procpar = ["f1DisplayInPPM   = \"$usePPMScale$\"",
              "f2DisplayInPPM   = \"$usePPMScale$\"",
              "f1FTOrigin       = \"Start\"",
              "f2FTOrigin       = \"Start\"",
              "f1FTType         = \"Complex\"",
              "f2FTType         = \"Complex\"",
              "f1WindowFunction = \"sinebellsquared\"",
              "f1WindowFunction = \"sinebellsquared\"",
              "f1FTInvert       = \"yes\"",
              "f2FTInvert       = \"no\"",
              "f1PhaseMethod    = \"Magnitude\"",
              "f2PhaseMethod    = \"None\"",
              "f1PPMOffset      = $centerFreqPPM$",
              "f2PPMOffset      = $centerFreqPPM$",
              "f1ZeroFill       = $zf$",
              "f2ZeroFill       = $zf$",
              "plotWidth        = $xrange[1]-xrange[0]$",
              "plotStart        = $xrange[0]$",
              "plotWidth2       = $yrange[1]-yrange[0]$",
              "plotStart2       = $yrange[0]$"]

   if(isvar("exptNr"))
      cd("$dataDirectory$\\$expName$\\$exptNr$")
   else
      cd("$dataDirectory$\\$expName$")
   endif

   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif
   save("proc.par",sortlist(procpar),"truedoubles")

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()



procedure( getTableFileAmp )

   objNr = findobj(0,"name","tableFileNameAmp")
print(getcwd())

   tableFileName = getobj(0,objNr)->text
   fileName = getfilename("open", "Select Amplitude table", "Table files", "txt", tableFileName)
print(getcwd())

   fileName=getcwd() +"\\" + fileName
   print(fileName)

   getobj(0,objNr)->text(fileName)
  

import1dpar("ab", "ascii", "xyrc", "real")
Amplitude=import1d(fileName)

(xs,xx)=size(Amplitude)
print(xs)
 objNr2 = findobj(0,"name","shapepoints")

   getobj(0,objNr2)->text(xs)
 
endproc()


 

procedure( getTableNUS )

   objNr = findobj(0,"name","tableFileNUS")
   tableFileName = getobj(0,objNr)->text
print(getcwd())
   fileName = getfilename("open", "Select NUS table", "Table files", "txt", tableFileName)
   fileName=getcwd() +"\\" + fileName

   print(fileName)
print(getcwd())

   getobj(0,objNr)->text(fileName)

endproc()
 




procedure( getTableFilePhase )

   objNr = findobj(0,"name","tableFileNamePh")
   tableFileName = getobj(0,objNr)->text
print(getcwd())
   fileName = getfilename("open", "Select Phase table", "Table files", "txt", tableFileName)
   fileName=getcwd() +"\\" + fileName

   print(fileName)
print(getcwd())

   getobj(0,objNr)->text(fileName)

endproc()
 


procedure(2dRF,mIn,w2,h2,fxs,fys,FTtypeX,FTtypeY,Magn)

   (w1,h1) = size(mIn)

# Check for too few arguments
     mOut = cmatrix(w2,h2)

endproc(mOut)
